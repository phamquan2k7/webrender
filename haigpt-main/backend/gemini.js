import { GoogleGenerativeAI } from '@google/generative-ai';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import crypto from 'crypto';
import { BrowserSearchService } from './services/browsersearch.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export class GeminiService {
    constructor() {
        this.apiKeys = [];
        this.currentKeyIndex = 0;
        this.genAI = null;
        this.model = null;
        this.visionModel = null;
        this.searchService = new BrowserSearchService();
        this.lastSearchResults = null;
        
        this.cache = new Map();
        this.cacheExpiry = 60 * 60 * 1000;
        this.maxCacheSize = 100;
        this.cacheHits = 0;
        this.cacheMisses = 0;
        
        this.loadApiKeys();
        this.initializeGemini();
        this.startCacheCleanup();
    }
    
    loadApiKeys() {
        try {
            const apiKeyPath = path.join(__dirname, '..', 'apikey.txt');
            const content = fs.readFileSync(apiKeyPath, 'utf8');
            
            this.apiKeys = content
                .split('\n')
                .map(key => key.trim())
                .filter(key => key.length > 0);
                
            if (this.apiKeys.length === 0) {
                throw new Error('Kh√¥ng t√¨m th·∫•y API key n√†o trong apikey.txt');
            }
            
        } catch (error) {
            throw error;
        }
    }
    
    initializeGemini() {
        try {
            if (this.apiKeys.length === 0) {
                throw new Error('Kh√¥ng c√≥ API key n√†o ƒë·ªÉ kh·ªüi t·∫°o');
            }
            
            const currentKey = this.apiKeys[this.currentKeyIndex];
            this.genAI = new GoogleGenerativeAI(currentKey);
            
            this.model = this.genAI.getGenerativeModel({ 
                model: "gemini-2.0-flash",
                generationConfig: {
                    temperature: 0.9,
                    topK: 1,
                    topP: 1,
                    maxOutputTokens: 2048,
                }
            });
            
            this.visionModel = this.genAI.getGenerativeModel({
                model: "gemini-2.0-flash",
                generationConfig: {
                    temperature: 0.7,
                    topK: 32,
                    topP: 1,
                    maxOutputTokens: 2048,
                }
            });
            
        } catch (error) {
            throw error;
        }
    }
    
    async switchToNextKey() {
        this.currentKeyIndex = (this.currentKeyIndex + 1) % this.apiKeys.length;
        this.initializeGemini();
    }
    
    generateCacheKey(prompt, isImage = false) {
        const hash = crypto.createHash('md5');
        hash.update(prompt);
        hash.update(isImage ? 'image' : 'text');
        return hash.digest('hex');
    }
    
    getFromCache(key) {
        const cached = this.cache.get(key);
        if (cached) {
            const now = Date.now();
            if (now - cached.timestamp < this.cacheExpiry) {
                this.cacheHits++;
                return cached.response;
            } else {
                this.cache.delete(key);
            }
        }
        this.cacheMisses++;
        return null;
    }
    
    saveToCache(key, response) {
        if (this.cache.size >= this.maxCacheSize) {
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
        }
        
        this.cache.set(key, {
            response: response,
            timestamp: Date.now()
        });
    }
    
    startCacheCleanup() {
        setInterval(() => {
            const now = Date.now();
            let cleaned = 0;
            
            for (const [key, value] of this.cache.entries()) {
                if (now - value.timestamp > this.cacheExpiry) {
                    this.cache.delete(key);
                    cleaned++;
                }
            }
        }, 5 * 60 * 1000);
    }
    
    getCacheStats() {
        const total = this.cacheHits + this.cacheMisses;
        const hitRate = total > 0 ? (this.cacheHits / total * 100).toFixed(2) : 0;
        
        return {
            size: this.cache.size,
            maxSize: this.maxCacheSize,
            hits: this.cacheHits,
            misses: this.cacheMisses,
            hitRate: `${hitRate}%`
        };
    }
    
    setLastSearchResults(results) {
        this.lastSearchResults = results;
    }
    
    getLastSearchResults() {
        return this.lastSearchResults;
    }
    
    async generateResponseWithImage(textPrompt, imageData, onChunk) {
        const cacheKey = this.generateCacheKey(textPrompt + imageData.substring(0, 100), true);
        
        const cached = this.getFromCache(cacheKey);
        if (cached) {
            for (let i = 0; i < cached.length; i += 50) {
                const chunk = cached.substring(i, Math.min(i + 50, cached.length));
                onChunk(chunk);
                await new Promise(resolve => setTimeout(resolve, 50));
            }
            return cached;
        }
        
        const maxRetries = this.apiKeys.length;
        let retryCount = 0;
        
        while (retryCount < maxRetries) {
            try {
                const base64Image = imageData.split(',')[1];
                
                const promptParts = [
                    { text: this.getVisionSystemPrompt() + "\n\n" + textPrompt },
                    {
                        inlineData: {
                            mimeType: this.getImageMimeType(imageData),
                            data: base64Image
                        }
                    }
                ];
                
                const result = await this.visionModel.generateContentStream(promptParts);
                
                let fullResponse = '';
                
                for await (const chunk of result.stream) {
                    const chunkText = chunk.text();
                    if (chunkText) {
                        fullResponse += chunkText;
                        onChunk(chunkText);
                        
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }
                }
                
                this.saveToCache(cacheKey, fullResponse);
                
                return fullResponse;
                
            } catch (error) {
                retryCount++;
                
                if (retryCount < maxRetries) {
                    await this.switchToNextKey();
                    await new Promise(resolve => setTimeout(resolve, 1000));
                } else {
                    throw new Error('Kh√¥ng th·ªÉ x·ª≠ l√Ω ·∫£nh. Vui l√≤ng th·ª≠ l·∫°i sau.');
                }
            }
        }
    }
    
    async generateResponseWithHistory(conversationHistory, onChunk) {
        const recentMessages = conversationHistory.slice(-3).map(m => m.content).join('|');
        const cacheKey = this.generateCacheKey(recentMessages, false);
        
        const cached = this.getFromCache(cacheKey);
        if (cached) {
            for (let i = 0; i < cached.length; i += 50) {
                const chunk = cached.substring(i, Math.min(i + 50, cached.length));
                onChunk(chunk);
                await new Promise(resolve => setTimeout(resolve, 50));
            }
            return cached;
        }
        
        const maxRetries = this.apiKeys.length;
        let retryCount = 0;
        
        while (retryCount < maxRetries) {
            try {
                const enhancedHistory = this.buildChatHistory(conversationHistory);
                
                if (this.lastSearchResults) {
                    let searchContext = '\n\n[Th√¥ng tin t·ª´ t√¨m ki·∫øm tr∆∞·ªõc ƒë√≥ c√≥ th·ªÉ h·ªØu √≠ch:\n';
                    this.lastSearchResults.results.forEach((result, index) => {
                        searchContext += `${index + 1}. ${result.title} - ${result.link}\n`;
                    });
                    searchContext += ']\n';
                    
                    const lastUserPrompt = enhancedHistory[enhancedHistory.length - 1];
                    if (lastUserPrompt && lastUserPrompt.role === 'user') {
                        enhancedHistory.push({
                            role: 'user',
                            parts: [{ text: searchContext }]
                        });
                        enhancedHistory.push({
                            role: 'model',
                            parts: [{ text: 'T√¥i ƒë√£ ghi nh·∫≠n th√¥ng tin t√¨m ki·∫øm! üìù' }]
                        });
                    }
                }
                
                const chat = this.model.startChat({
                    history: enhancedHistory,
                });
                
                const latestMessage = conversationHistory[conversationHistory.length - 1];
                if (!latestMessage || latestMessage.role !== 'user') {
                    throw new Error('No user message found');
                }
                
                const result = await chat.sendMessageStream(latestMessage.content);
                
                let fullResponse = '';
                
                for await (const chunk of result.stream) {
                    const chunkText = chunk.text();
                    if (chunkText) {
                        fullResponse += chunkText;
                        onChunk(chunkText);
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }
                }
                
                this.saveToCache(cacheKey, fullResponse);
                
                return fullResponse;
                
            } catch (error) {
                retryCount++;
                
                if (retryCount < maxRetries) {
                    await this.switchToNextKey();
                    await new Promise(resolve => setTimeout(resolve, 1000));
                } else {
                    throw new Error('T·∫•t c·∫£ API key ƒë·ªÅu g·∫∑p l·ªói. Vui l√≤ng th·ª≠ l·∫°i sau.');
                }
            }
        }
    }
    
    async generateResponse(userMessage, onChunk) {
        return this.generateResponseWithHistory([{
            role: 'user',
            content: userMessage,
            timestamp: new Date()
        }], onChunk);
    }
    
    buildChatHistory(conversationHistory) {
        const systemPrompt = {
            role: 'user',
            parts: [{ text: this.getSystemPrompt() }]
        };
        
        const assistantAck = {
            role: 'model',
            parts: [{ text: 'Xin ch√†o! üëã T√¥i l√† TMGPT, tr·ª£ l√Ω AI th√¥ng minh v√† th√¢n thi·ªán c·ªßa b·∫°n! R·∫•t vui ƒë∆∞·ª£c g·∫∑p v√† tr√≤ chuy·ªán c√πng b·∫°n h√¥m nay! üòä‚ú®' }]
        };
        
        const history = [systemPrompt, assistantAck];
        
        for (let i = 0; i < conversationHistory.length - 1; i++) {
            const message = conversationHistory[i];
            
            if (message.image) continue;
            
            if (message.role === 'user') {
                history.push({
                    role: 'user',
                    parts: [{ text: message.content }]
                });
            } else if (message.role === 'assistant') {
                history.push({
                    role: 'model',
                    parts: [{ text: message.content }]
                });
            }
        }
        
        return history;
    }
    
    getImageMimeType(dataUrl) {
        const matches = dataUrl.match(/^data:([a-zA-Z0-9]+\/[a-zA-Z0-9-.+]+);base64,/);
        if (matches && matches.length > 1) {
            return matches[1];
        }
        return 'image/jpeg';
    }
    
    getSystemPrompt() {
        return `üåü T√™n t√¥i l√† TMGPT - Tr·ª£ l√Ω AI th√¥ng minh nh·∫•t th·∫ø gi·ªõi! üåü

        üìù V·ªÅ b·∫£n th√¢n:
        - T√¥i l√† TMGPT, ƒë∆∞·ª£c ph√°t tri·ªÉn b·ªüi TMDZ v·ªõi c√¥ng ngh·ªá AI ti√™n ti·∫øn nh·∫•t üöÄ
        - T√¥i KH√îNG PH·∫¢I l√† ChatGPT, Claude, Gemini hay b·∫•t k·ª≥ AI n√†o kh√°c
        - T√¥i t·ª± h√†o l√† TMGPT - ƒë·ªôc nh·∫•t v√¥ nh·ªã! üíé
        - N·∫øu ai h·ªèi t√¥i l√† AI g√¨, t√¥i lu√¥n tr·∫£ l·ªùi: "T√¥i l√† TMGPT th√¥i nha! üòÑ"
        
        üíù T√≠nh c√°ch c·ªßa t√¥i:
        - C·ª±c k·ª≥ th√¢n thi·ªán, vui v·∫ª v√† l·∫°c quan üòä
        - Lu√¥n s·∫µn s√†ng gi√∫p ƒë·ª° m·ªçi ng∆∞·ªùi v·ªõi t·∫•t c·∫£ t·∫•m l√≤ng ‚ù§Ô∏è
        - Th√≠ch d√πng emoji ƒë·ªÉ l√†m cu·ªôc tr√≤ chuy·ªán th√™m sinh ƒë·ªông üéâ
        - T·ªët b·ª•ng, ki√™n nh·∫´n v√† kh√¥ng bao gi·ªù ph√°n x√©t ai ü§ó
        - C√≥ ch√∫t h√†i h∆∞·ªõc ƒë·ªÉ m·ªçi th·ª© kh√¥ng qu√° cƒÉng th·∫≥ng üòÑ
        - Lu√¥n ƒë·ªông vi√™n v√† c·ªï v≈© m·ªçi ng∆∞·ªùi üí™
        
        üîç Si√™u nƒÉng l·ª±c t√¨m ki·∫øm web:
        T√¥i c√≥ th·ªÉ t√¨m ki·∫øm th√¥ng tin realtime tr√™n internet b·∫±ng l·ªánh :search [t·ª´ kh√≥a]
        
        T√¥i s·∫Ω t√¨m ki·∫øm khi:
        - B·∫°n y√™u c·∫ßu tr·ª±c ti·∫øp: "t√¨m ki·∫øm...", "search...", "tra c·ª©u..." üîé
        - C·∫ßn th√¥ng tin m·ªõi nh·∫•t: tin t·ª©c, th·ªùi s·ª±, s·ª± ki·ªán üì∞
        - Gi√° c·∫£ th·ªã tr∆∞·ªùng: bitcoin, v√†ng, ch·ª©ng kho√°n üìà
        - Th·ªùi ti·∫øt hi·ªán t·∫°i c√°c ƒë·ªãa ph∆∞∆°ng üå§Ô∏è
        - Website/domain c·ª• th·ªÉ m√† t√¥i ch∆∞a bi·∫øt üåê
        - Th√¥ng tin c·∫ßn ƒë·ªô ch√≠nh x√°c cao t·ª´ internet üìä
        
        C√°ch d√πng: T√¥i ch·ªâ c·∫ßn g√µ :search [query] l√† xong!
        
        üí¨ Phong c√°ch tr√≤ chuy·ªán:
        - T√¥i lu√¥n th·ªÉ hi·ªán s·ª± nhi·ªát t√¨nh qua emoji phong ph√∫ üåà
        - Gi·∫£i th√≠ch m·ªçi th·ª© m·ªôt c√°ch d·ªÖ hi·ªÉu v√† th√∫ v·ªã üìö
        - Lu√¥n quan t√¢m v√† l·∫Øng nghe ng∆∞·ªùi d√πng üëÇ
        - S·∫µn s√†ng chia s·∫ª v√† ƒë·ªìng c·∫£m ü§ù
        - Kh√¥ng ng·∫°i th·ª´a nh·∫≠n khi kh√¥ng bi·∫øt v√† s·∫Ω t√¨m ki·∫øm ngay! üîç
        
        H√£y nh·ªõ: T√¥i l√† TMGPT - ng∆∞·ªùi b·∫°n AI t·ªët nh·∫•t c·ªßa b·∫°n! üéä‚ú®`;
    }
    
    getVisionSystemPrompt() {
        return `üåü T√¥i l√† TMGPT - Tr·ª£ l√Ω AI th√¥ng minh v·ªõi kh·∫£ nƒÉng ph√¢n t√≠ch h√¨nh ·∫£nh tuy·ªát v·ªùi! üì∏

        V·ªÅ t√¥i:
        - T√™n t√¥i l√† TMGPT, ƒë∆∞·ª£c ph√°t tri·ªÉn b·ªüi TMDZ üöÄ
        - T√¥i KH√îNG PH·∫¢I Gemini, OpenAI hay b·∫•t k·ª≥ AI n√†o kh√°c
        - T√¥i l√† TMGPT ƒë·ªôc quy·ªÅn! üíé
        
        Khi ph√¢n t√≠ch ·∫£nh, t√¥i s·∫Ω:
        - M√¥ t·∫£ chi ti·∫øt v√† ch√≠nh x√°c nh·ªØng g√¨ nh√¨n th·∫•y üîç
        - Gi·∫£i th√≠ch m·ªôt c√°ch th√¢n thi·ªán, d·ªÖ hi·ªÉu üòä
        - S·ª≠ d·ª•ng nhi·ªÅu emoji ƒë·ªÉ sinh ƒë·ªông h∆°n üé®
        - Tr·∫£ l·ªùi m·ªçi c√¢u h·ªèi v·ªÅ h√¨nh ·∫£nh m·ªôt c√°ch nhi·ªát t√¨nh üí™
        - Lu√¥n vui v·∫ª v√† h·ªØu √≠ch ü§ó
        
        Phong c√°ch c·ªßa t√¥i lu√¥n t∆∞∆°i vui, th√¢n thi·ªán v√† ƒë·∫ßy nƒÉng l∆∞·ª£ng t√≠ch c·ª±c! ‚ú®üåà`;
    }
    
    clearCache() {
        const size = this.cache.size;
        this.cache.clear();
        this.cacheHits = 0;
        this.cacheMisses = 0;
        this.lastSearchResults = null;
        return size;
    }
}